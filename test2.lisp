(defvar temp_list ())
(defvar temp_value)

(defun printem (&rest args)
  (format t "~{~a~^ ~}" args))

(defun evaluate (e env)
  (let ((res (valid-args? e)))
    (if (car res)
        (if (atom e)
            (cond
              ((constant? e) e)
              ((symbol? e) (lookup e env))
              ((or (procedure? e) (numberp e)) e)
              (t (wrong "Could not evaluate expression: ~S~%" e)))
            (case (car e)
              ((progn) (eprogn (cdr e) env))
              ((setf) (update! (cadr e) env (evaluate (caddr e) env)))
              ((if) (if-expr (cdr e) env))
              ((let) (IlllIll (cdr e) env))
              (t (invoke (evaluate (car e) env) (evlist (cdr e) env)))))
        (format t "Invalid number of args: expected ~d, got ~d in ~S~%" (caddr res) (cadr res) e))))

(defun if-expr (e env)
    (return-from if-expr (if (evaluate (car e) env) (evaluate (cadr e) env) (evaluate (caddr e) env)))
)

(defun ilIllI (IlllIllIL)
    (if (typep (car (cdr (car ls))) 'cons)
        (setf temp_value (car (evlist (cdr (car IlllIllIL)) temp_list)))
    )
    (if (typep (car (cdr (car ls))) 'cons)
        (return-from ilIllI (cons (car (car IlllIllIL)) temp_value))
        (return-from ilIllI (cons (car (car IlllIllIL)) (car (cdr (car ls)))))
    )
)

(defun IlllIll (IllIlIll IllIllllI)
    (if (typep IllIllllI 'cons)
        (push (car IllIllllI) temp_list)
    )
    (dolist (x (car IllIlIll))
        (push (ilIllI (list x)) temp_list)
    )
    (if (car (valid-args? IllIlIll))
        (evlist (cdr IllIlIll) temp_list)
    )

    (if (> (length (cdr IllIlIll)) 1) 
        (return-from IlllIll (car (evlist (cdr (cdr IllIlIll)) temp_list)))
        (return-from IlllIll (evaluate (car (cdr IllIlIll)) temp_list))    
    )
)

(defun lookup (e env)
  (let ((v (assoc e env)))
    (if v (cdr v)
        (wrong "Unbound-variable: ~S~%" e))))

(defun update! (var env value)
    ;(print var)(print env)(print value)
  (let ((kv (assoc var env)))
    (setf (cdr kv) value)
       )
)

(defun eprogn (el env)
  (let ((result (evaluate (car el) env)))
    (dolist (e (cdr el) result)
      (setf result (evaluate e env)))))

(defun procedure? (fn)
  (or (eql fn '+)
      (eql fn '-)
      (eql fn '*)
      (eql fn '/)))

(defun wrong (m &optional v)
  (format t m v))

(defun check-arg-types (fn args)
  (and (procedure? fn)
       (numberp (first args))
       (numberp (second args))))

(defun invoke (fn args)
  (if (procedure? fn)
      (apply fn args)
      (wrong "Could not evaluate function: ~S" fn)))

(defun evlist (lis env)
  (when lis
    (let ((a (evaluate (car lis) env)))
      (cons a (evlist (cdr lis) env)))))

(defun constant? (s)
  (or (eql s 'nil)
      (eql s 't)
      (stringp s)))

(defun symbol? (s)
  (and (symbolp s) (not (procedure? s)) (not (constant? s))))

(defun valid-args-num? (lst num)
  (let* ((len (length lst)) (res (= len num)))
    (list res len num)))

(defun valid-args? (lst)
  (if (eql (type-of lst) 'cons)
      (case (car lst)
        ((setf) (valid-args-num? lst 3))
        ((if) (valid-args-num? lst 4))
        ((let)
         (progn
           (loop for item in (cadr lst) do
             (let ((res (valid-args-num? item 2)))
               (if (not (car res))
                   (return-from valid-args? (list nil (cadr res) 2)))))
           '(t 2 2)))
        (t (let ((len (length lst)))
             (list t len len))))
      '(t 0 0)))
