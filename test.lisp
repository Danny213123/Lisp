(defvar a)(defvar z)(defvar l)(defvar p)(defvar h)
(defvar fl
    '((start . test1) (test1 init end1) (init . test2) (test2 bdy return) (bdy . incr) (incr . test2) (return . end1) (end1)))
(defun next-state (l g)(setf a (cdr(assoc g l)))(return-from next-state a))
(defun v (b s x)
  ;(setf k (list s))
  (if (equal (next-state b x) nil)(return-from v nil)(progn(if (equal x s)(if (equal (next-state b x) nil)
                (return-from v nil)
                (return-from v (next-state b x))
                )
            (progn(setf z (next-state b x))(if (typep z 'list)(dolist (e z)(setf p (v b s e))(if (equal p nil) () (return-from v p)))
                  (v b s (next-state b x))))))))
(defun jump-state (n s x)(setf h (v n s x))
    (if (equal h nil)(if (equal h s)(return-from jump-state x)(return-from jump-state nil))(return-from jump-state h)
    ))
(defun next-fork (q s)
    (if (or (equal s nil) (typep s 'list))(return-from next-fork s)(next-fork q (next-state q s))))

(defun interleave (a b)
    (if (equal (length a) 0)(return-from interleave b))(if (equal (length b) 0)(return-from interleave a))
    (return-from interleave (cons (car a) (cons (car b) (interleave (cdr a) (cdr b))))))

(defun recomb (n k)
    (if (< n 0) (return-from recomb 0))(if (or (equal n k) (equal n 0)) (return-from recomb 1)(if (and (> n k) (> k 0))
      (return-from recomb (+ (recomb (- n 1) k) (recomb (- n 1) (- k 1))))(return-from recomb 1))))

(defun comb (n k)
    (if (or (equal (recomb n k) 0) (< n k))(return-from comb nil)(return-from comb (recomb n k))
    ))
